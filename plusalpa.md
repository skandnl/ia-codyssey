1. Run Without Debugging (디버그 없이 실행) vs Start Debugging (디버그 시작)
구분	Run Without Debugging	Start Debugging
목적	가볍게 실행해서 결과만 확인할 때	중단점(Breakpoint), 변수 값 추적, 스택 확인 등 디버깅 도구를 활용할 때
프로세스	python app.py 와 거의 동일하게 하나의 프로세스만 띄움	Debug Adapter가 함께 뜨며, 코드가 다른 프로세스(디버거) 밑에서 동작
중단점	무시됨(멈추지 않음)	중단점에서 일시정지, 변수·호출스택·워치 다 볼 수 있음
속도	초기 실행이 빠름	디버거 로딩·추적 오버헤드로 조금 느림
종료	Stop Debugging 클릭 시 즉시 프로세스 종료	같은 버튼(■)로 디버거+타깃 프로세스를 함께 종료
언제 쓰나	“결과만 확인”·“단순 테스트”	“버그 위치 찾기”·“흐름·값 확인”

팁: 간단한 Flask 라우트나 CLI 스크립트를 여러 번 고쳐 가며 돌려볼 땐 Run Without Debugging이 훨씬 빠릅니다. 반면 예외가 어디서 터지는지, 파라미터가 이상한지 확인할 땐 Start Debugging으로 브레이크포인트를 걸어 놓고 추적하세요.

2. Flask의 역할 한 줄 요약
“파이썬 함수(비즈니스 로직)를 웹 요청/응답(HTTP)으로 노출·라우팅해 주는 초경량 WSGI 웹 프레임워크”

URL 경로를 함수에 매핑(@app.route("/"))

개발용 서버 제공 (flask run, app.run() 등)

요청 객체(request), 응답 객체(response) 추상화

템플릿 Jinja2, 세션, 쿠키, 확장(ORM, 인증) 등은 필요할 때만 선택

3. 호스트를 0.0.0.0으로 지정할 때의 의미·장단점
0.0.0.0
의미	“모든 IPv4 인터페이스에서 들어오는 요청을 수신하라” – PC 자체 IP(127.0.0.1, 192.168.x.y, 10.x.y.z 등)를 전부 바인딩
장점	- 같은 LAN에 있는 **다른 장치(스마트폰, 동료 PC)**에서도 바로 접속 가능
- Docker·WSL 같은 가상화/컨테이너 안에서 호스트→컨테이너 접근 시 편리
단점	- 외부에서 접근 가능한 네트워크라면 의도치 않은 공개 위험
- 방화벽 규칙을 잘못 설정할 경우 공격 표면 확대

개발 단계에선 편하지만, 운영 서버에서는 방화벽·리버스 프록시(Nginx) 뒤에서 제한된 포트만 노출하는 것이 안전합니다.

4. 127.0.0.1(루프백) 접속 vs 내부 IP 접속
127.0.0.1	내부 IP(예: 192.168.0.12)
경로	OS 네트워크 스택을 돌긴 하지만 NIC(네트워크 카드)까지 안 나감	실제 LAN 카드를 통해 물리적/가상 네트워크 전송
속도	메모리 수준(가장 빠름)	스위치·공유기·가상 브릿지 등 경유 → 조금 느려짐
접근 대상	동일 머신에서만 접근 가능	같은 서브넷 기기 누구나(IP 알고 있으면) 접근
주 용도	로컬 개발·테스트, DB Unix 소켓 대체	사내·가정용 테스트, 디바이스 연동, 멀티 머신 디버깅
보안	외부 노출 無	네트워크 방화벽 등으로 별도 보호 필요

5. 포트 번호란? 기본 충돌 해결법
포트(Port): 한 IP 주소 안에서 프로세스를 구분하는 16비트 번호(0–65535).

0–1023: Well‑known(HTTP 80, HTTPS 443, SSH 22 등, root/관리자 권한 필요)

1024–49151: 등록 포트(공식 서비스·애플리케이션)

49152–65535: 동적/사설 포트(개발·임시 용)